name: Azure Deployment Pipeline

# This workflow handles deployment of all Azure resources and functions
# Consolidation of all separate workflows to reduce confusion

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  AZURE_FUNCTIONAPP_NAME: "blogauto-${{ vars.ENVIRONMENT || 'dev' }}-function"
  PYTHON_VERSION: '3.11'
  RESOURCE_GROUP: "blogauto-${{ vars.ENVIRONMENT || 'dev' }}-rg"
  # Default location for production is westus due to quota availability
  # For other environments, use eastus
  LOCATION: ${{ vars.ENVIRONMENT == 'prod' && 'westus' || vars.LOCATION || 'eastus' }}
  ENVIRONMENT: ${{ vars.ENVIRONMENT || 'dev' }}
  PROJECT_NAME: "blogauto"
  # Default WordPress admin settings
  WP_ADMIN_EMAIL: ${{ vars.WP_ADMIN_EMAIL || 'admin@example.com' }}

jobs:
  lint-and-test:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install flake8 pytest azure-functions
        # Install src requirements
        if [ -f src/requirements.txt ]; then
          pip install -r src/requirements.txt
        fi
        
    - name: Lint with flake8
      run: |
        # stop the build if there are Python syntax errors or undefined names
        flake8 src/ --count --select=E9,F63,F7,F82 --show-source --statistics
        # exit-zero treats all errors as warnings
        flake8 src/ --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics
        
    - name: Test with pytest
      run: |
        pytest

  validate-bicep:
    runs-on: ubuntu-latest
    needs: lint-and-test
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      
    - name: Install Bicep CLI
      run: |
        curl -Lo bicep https://github.com/Azure/bicep/releases/latest/download/bicep-linux-x64
        chmod +x ./bicep
        sudo mv ./bicep /usr/local/bin/bicep
        
    - name: Validate Bicep templates
      run: |
        bicep build infra/main.bicep
        bicep build infra/storage.bicep
        bicep build infra/functions.bicep
        bicep build infra/keyvault.bicep
        bicep build infra/monitoring.bicep
        if [ -f infra/wordpress.bicep ]; then
          bicep build infra/wordpress.bicep
        fi

  deploy-infra:
    runs-on: ubuntu-latest
    needs: validate-bicep
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      
    - name: Azure login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
        
    - name: Create resource group if not exists
      run: |
        az group create --name "${{ env.RESOURCE_GROUP }}" --location "${{ env.LOCATION }}"
        
    - name: Deploy Azure infrastructure
      run: |
        # Deploy Azure infrastructure using Bicep template
        # Always deploy WordPress (deployWordPress=true) with secure passwords from secrets
        az deployment group create \
          --resource-group "${{ env.RESOURCE_GROUP }}" \
          --template-file ./infra/main.bicep \
          --parameters projectName="${{ env.PROJECT_NAME }}" \
          --parameters environment="${{ env.ENVIRONMENT }}" \
          --parameters location="${{ env.LOCATION }}" \
          --parameters deployWordPress=true \
          --parameters wpAdminEmail="${{ env.WP_ADMIN_EMAIL }}" \
          --parameters dbAdminPassword="${{ secrets.DB_ADMIN_PASSWORD || 'Wp@ssw0rd12345!' }}" \
          --parameters wpAdminPassword="${{ secrets.WP_ADMIN_PASSWORD || 'Wp@ssw0rd54321!' }}" \
          --name "github-${{ github.run_number }}"

  deploy-function:
    runs-on: ubuntu-latest
    needs: deploy-infra
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        if [ -f src/requirements.txt ]; then
          pip install -r src/requirements.txt
        fi
        pip install azure-functions
        
    - name: Azure login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
        
    - name: Debug Environment
      run: |
        echo "Function App Name: ${{ env.AZURE_FUNCTIONAPP_NAME }}"
        echo "Python Version: ${{ env.PYTHON_VERSION }}"
        echo "Environment: ${{ env.ENVIRONMENT }}"
        echo "Resource Group: ${{ env.RESOURCE_GROUP }}"
      
    # First, prepare the web app deployment package including admin portal
    - name: Prepare web application deployment package
      run: |
        echo "Preparing web application deployment package"
        mkdir -p deploy-package
        
        # Copy function code
        cp -r src/* deploy-package/
        
        # Copy admin portal files
        cp -r templates static deploy-package/
        
        # Ensure data directory exists
        mkdir -p deploy-package/data
        # Create data directories if they don't exist
        if [ -d data ]; then
          cp -r data/* deploy-package/data/
        fi
        
        # Copy main application files
        cp main.py deploy-package/
        cp wsgi.py deploy-package/
        cp minimal_app.py deploy-package/  # Add fallback app
        
        # Copy web configuration files
        cp web.config deploy-package/
        chmod +x startup.sh
        cp startup.sh deploy-package/
        
        # Copy troubleshooting scripts
        chmod +x fix-webapp-directly.sh deploy-static-test.sh direct-fix.sh deploy-admin-portal.sh
        cp fix-webapp-directly.sh deploy-static-test.sh direct-fix.sh deploy-admin-portal.sh deploy-package/
        
        # Create error pages
        mkdir -p deploy-package/errors
        
        # Create 404 page
        cat > deploy-package/404.html << EOF
        <!DOCTYPE html>
        <html>
        <head>
            <title>404 - Page Not Found</title>
            <style>
                body { font-family: Arial, sans-serif; margin: 40px; line-height: 1.6; text-align: center; }
                h1 { color: #0066cc; }
                .container { border: 1px solid #ddd; padding: 20px; border-radius: 5px; max-width: 600px; margin: 0 auto; }
            </style>
        </head>
        <body>
            <h1>404 - Page Not Found</h1>
            <div class="container">
                <p>The page you requested could not be found.</p>
                <p><a href="/">Return to Dashboard</a></p>
            </div>
        </body>
        </html>
        EOF
        
        # Create 500 page
        cat > deploy-package/500.html << EOF
        <!DOCTYPE html>
        <html>
        <head>
            <title>500 - Server Error</title>
            <style>
                body { font-family: Arial, sans-serif; margin: 40px; line-height: 1.6; text-align: center; }
                h1 { color: #cc0000; }
                .container { border: 1px solid #ddd; padding: 20px; border-radius: 5px; max-width: 600px; margin: 0 auto; }
            </style>
        </head>
        <body>
            <h1>500 - Server Error</h1>
            <div class="container">
                <p>The server encountered an internal error and was unable to complete your request.</p>
                <p>Please try again later or contact the administrator.</p>
                <p><a href="/">Return to Dashboard</a></p>
            </div>
        </body>
        </html>
        EOF
        
        # Create hostingstart.html (fallback page)
        cat > deploy-package/hostingstart.html << EOF
        <!DOCTYPE html>
        <html>
        <head>
            <title>Blog Automation Admin Portal</title>
            <style>
                body { font-family: Arial, sans-serif; margin: 40px; line-height: 1.6; }
                h1 { color: #0066cc; }
                .container { border: 1px solid #ddd; padding: 20px; border-radius: 5px; }
                .info { color: #0066cc; background-color: #e7f9f9; padding: 15px; border-radius: 5px; margin-bottom: 20px; }
            </style>
        </head>
        <body>
            <h1>Blog Automation Admin Portal</h1>
            
            <div class="info">
                <strong>Startup in Progress:</strong> The Blog Automation Admin Portal is starting up. If this page persists, check the application logs.
            </div>
            
            <div class="container">
                <h2>Quick Links</h2>
                <ul>
                    <li><a href="/admin">Admin Dashboard</a></li>
                    <li><a href="/api">API Endpoints</a></li>
                    <li><a href="/docs">Documentation</a></li>
                </ul>
            </div>
        </body>
        </html>
        EOF
        
        # Make script files executable
        find deploy-package -name "*.sh" -exec chmod +x {} \;
        
        # Copy or create requirements file
        if [ -f requirements.txt ]; then
          cp requirements.txt deploy-package/
        else
          # Create comprehensive requirements if none exists
          cat > deploy-package/requirements.txt << EOF
        flask>=2.0.0
        gunicorn>=20.1.0
        wfastcgi>=3.0.0
        python-dotenv>=0.19.0
        werkzeug>=2.0.1
        azure-functions>=1.11.0
        azure-identity>=1.10.0
        azure-keyvault-secrets>=4.5.0
        azure-storage-blob>=12.13.0
        requests>=2.27.1
        markdown>=3.3.7
        pygments>=2.13.0
        langdetect>=1.0.9
        trafilatura>=1.4.0
        EOF
        fi
        
        # Create required Azure configuration files
        echo '{"version":"2.0","extensionBundle":{"id":"Microsoft.Azure.Functions.ExtensionBundle","version":"[2.*, 3.0.0)"}}' > deploy-package/host.json
        
        # Create a '.deployment' file to control deployment behavior
        echo '[config]' > deploy-package/.deployment
        echo 'SCM_DO_BUILD_DURING_DEPLOYMENT=true' >> deploy-package/.deployment
        
        # Create a simple route.json file to indicate this is a web app
        echo '{"routes":[{"route":"/*","serve":"/"}]}' > deploy-package/routes.json
        
        # Ensure proper file permissions
        chmod -R 755 deploy-package
        
        # List the contents of the deploy package
        echo "Deploy package contents:"
        ls -la deploy-package
        echo "Web config file:"
        cat deploy-package/web.config

    - name: Deploy Function App and Web App
      uses: Azure/functions-action@v1
      with:
        app-name: ${{ env.AZURE_FUNCTIONAPP_NAME }}
        package: deploy-package
        scm-do-build-during-deployment: true
        enable-oryx-build: true
        respect-pom-xml: false
        respect-funcignore: false
      env:
        AZURE_FUNCTIONAPP_PACKAGE_PATH: deploy-package
        PYTHON_VERSION: ${{ env.PYTHON_VERSION }}

    - name: Configure Admin Portal
      run: |
        echo "Running post-deployment configuration to properly set up admin portal..."
        chmod +x ./configure-admin-portal.sh
        
        # Run configuration script and continue even if it fails
        if ./configure-admin-portal.sh "${{ env.RESOURCE_GROUP }}" "${{ env.AZURE_FUNCTIONAPP_NAME }}"; then
          echo "Admin portal configuration completed successfully."
        else
          echo "Admin portal configuration had some warnings, but deployment will continue."
          echo "You may need to manually check the admin portal configuration."
        fi
        
    - name: Prepare Fallback Mechanism
      run: |
        echo "Setting up fallback mechanisms for maximum reliability..."
        
        # Create minimal app and error pages for fallback
        chmod +x ./fix-webapp-directly.sh
        ./fix-webapp-directly.sh "${{ env.RESOURCE_GROUP }}" "${{ env.AZURE_FUNCTIONAPP_NAME }}" || true
        
        # Deploy static test as a backup option
        chmod +x ./deploy-static-test.sh
        ./deploy-static-test.sh "${{ env.RESOURCE_GROUP }}" "${{ env.AZURE_FUNCTIONAPP_NAME }}" || true
        
    - name: Final Web App Configuration
      run: |
        echo "Performing final crucial web app configuration steps..."
        
        # Configure the app as a web app (not a function app)
        az resource update \
          --resource-group "${{ env.RESOURCE_GROUP }}" \
          --name "${{ env.AZURE_FUNCTIONAPP_NAME }}" \
          --resource-type "Microsoft.Web/sites" \
          --set kind="app,linux" \
          --api-version "2021-02-01"
        
        # Force the app to be a web app and set the right startup command
        az webapp config set \
          --resource-group "${{ env.RESOURCE_GROUP }}" \
          --name "${{ env.AZURE_FUNCTIONAPP_NAME }}" \
          --startup-file "gunicorn --bind=0.0.0.0:5000 --timeout 600 wsgi:application"
        
        # Set crucial app settings that make Flask work as a web app
        az webapp config appsettings set \
          --resource-group "${{ env.RESOURCE_GROUP }}" \
          --name "${{ env.AZURE_FUNCTIONAPP_NAME }}" \
          --settings \
          FLASK_APP=main.py \
          WEBSITES_PORT=5000 \
          PORT=5000 \
          SCM_DO_BUILD_DURING_DEPLOYMENT=true \
          WSGI_LOG=D:\\home\\LogFiles\\application.log
        
        # Force HTTPS
        az webapp update \
          --resource-group "${{ env.RESOURCE_GROUP }}" \
          --name "${{ env.AZURE_FUNCTIONAPP_NAME }}" \
          --https-only true
        
        # Configure default documents to handle both scenarios
        az webapp config set \
          --resource-group "${{ env.RESOURCE_GROUP }}" \
          --name "${{ env.AZURE_FUNCTIONAPP_NAME }}" \
          --generic-configurations "{'defaultDocuments': ['index.html','default.htm','hostingstart.html']}"
        
        # Final restart to apply all settings
        az webapp restart \
          --resource-group "${{ env.RESOURCE_GROUP }}" \
          --name "${{ env.AZURE_FUNCTIONAPP_NAME }}"
          
        # Wait for the app to become available
        echo "Waiting for the web app to become available..."
        sleep 60
        
        # Check if the app is accessible
        HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "https://${{ env.AZURE_FUNCTIONAPP_NAME }}.azurewebsites.net/")
        echo "Web app responded with HTTP code: $HTTP_CODE"
        
        if [ "$HTTP_CODE" != "200" ]; then
          echo "Warning: Web app not returning 200 OK. Attempting emergency direct fix..."
          chmod +x ./direct-fix.sh
          ./direct-fix.sh "${{ env.RESOURCE_GROUP }}" "${{ env.AZURE_FUNCTIONAPP_NAME }}" || true
          
          # Wait a bit more and check again
          sleep 30
          FINAL_HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "https://${{ env.AZURE_FUNCTIONAPP_NAME }}.azurewebsites.net/")
          echo "Final HTTP code after emergency fix: $FINAL_HTTP_CODE"
        fi