name: Azure Deployment Pipeline

# This workflow handles deployment of all Azure resources, functions, and admin portal
# Clean implementation with dedicated admin portal web app

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  AZURE_FUNCTIONAPP_NAME: "blogauto-${{ vars.ENVIRONMENT || 'dev' }}-function"
  ADMIN_PORTAL_NAME: "blogauto-${{ vars.ENVIRONMENT || 'dev' }}-admin"
  PYTHON_VERSION: '3.11'
  RESOURCE_GROUP: "blogauto-${{ vars.ENVIRONMENT || 'dev' }}-rg"
  # Default location for production is westus due to quota availability
  # For other environments, use eastus
  LOCATION: ${{ vars.ENVIRONMENT == 'prod' && 'westus' || vars.LOCATION || 'eastus' }}
  ENVIRONMENT: ${{ vars.ENVIRONMENT || 'dev' }}
  PROJECT_NAME: "blogauto"
  # Default WordPress admin settings
  WP_ADMIN_EMAIL: ${{ vars.WP_ADMIN_EMAIL || 'admin@example.com' }}

jobs:
  lint-and-test:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install flake8 pytest azure-functions
        # Install src requirements
        if [ -f src/requirements.txt ]; then
          pip install -r src/requirements.txt
        fi
        
    - name: Lint with flake8
      run: |
        # stop the build if there are Python syntax errors or undefined names
        flake8 src/ --count --select=E9,F63,F7,F82 --show-source --statistics
        # exit-zero treats all errors as warnings
        flake8 src/ --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics
        
    - name: Test with pytest
      run: |
        pytest

  validate-bicep:
    runs-on: ubuntu-latest
    needs: lint-and-test
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      
    - name: Install Bicep CLI
      run: |
        curl -Lo bicep https://github.com/Azure/bicep/releases/latest/download/bicep-linux-x64
        chmod +x ./bicep
        sudo mv ./bicep /usr/local/bin/bicep
        
    - name: Validate Bicep templates
      run: |
        bicep build infra/main.bicep
        bicep build infra/storage.bicep
        bicep build infra/functions.bicep
        bicep build infra/keyvault.bicep
        bicep build infra/keyvault-access-policies.bicep
        bicep build infra/monitoring.bicep
        bicep build infra/admin-portal.bicep
        bicep build infra/admin-portal-identity.bicep
        if [ -f infra/wordpress.bicep ]; then
          bicep build infra/wordpress.bicep
        fi

  deploy-infra:
    runs-on: ubuntu-latest
    needs: validate-bicep
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      
    - name: Azure login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
        
    - name: Create resource group if not exists
      run: |
        az group create --name "${{ env.RESOURCE_GROUP }}" --location "${{ env.LOCATION }}"
        
    - name: Get GitHub service principal ID
      id: get-sp-id
      run: |
        # Extract the object ID of the GitHub service principal from the credentials
        CREDENTIAL_JSON='${{ secrets.AZURE_CREDENTIALS }}'
        OBJECT_ID=$(echo $CREDENTIAL_JSON | grep -o '"object_id":\s*"[^"]*"' | cut -d'"' -f4 || echo "")
        
        if [ -z "$OBJECT_ID" ]; then
          # Try to find it from client_id
          CLIENT_ID=$(echo $CREDENTIAL_JSON | grep -o '"clientId":\s*"[^"]*"' | cut -d'"' -f4)
          if [ -n "$CLIENT_ID" ]; then
            echo "Retrieving object ID from client ID..."
            OBJECT_ID=$(az ad sp show --id $CLIENT_ID --query "id" --output tsv 2>/dev/null || echo "")
          fi
        fi
        
        if [ -n "$OBJECT_ID" ]; then
          echo "Found service principal object ID: $OBJECT_ID"
          echo "DEPLOYMENT_PRINCIPAL_ID=$OBJECT_ID" >> $GITHUB_ENV
        else
          echo "⚠️ Could not determine service principal object ID. RBAC permissions for storage account may not be applied."
          echo "DEPLOYMENT_PRINCIPAL_ID=" >> $GITHUB_ENV
        fi
        
    - name: Deploy Azure infrastructure
      run: |
        # Deploy Azure infrastructure using Bicep template
        # Always deploy WordPress (deployWordPress=true) with secure passwords from secrets
        az deployment group create \
          --resource-group "${{ env.RESOURCE_GROUP }}" \
          --template-file ./infra/main.bicep \
          --parameters projectName="${{ env.PROJECT_NAME }}" \
          --parameters environment="${{ env.ENVIRONMENT }}" \
          --parameters location="${{ env.LOCATION }}" \
          --parameters deployWordPress=true \
          --parameters wpAdminEmail="${{ env.WP_ADMIN_EMAIL }}" \
          --parameters dbAdminPassword="${{ secrets.DB_ADMIN_PASSWORD || 'Wp@ssw0rd12345!' }}" \
          --parameters wpAdminPassword="${{ secrets.WP_ADMIN_PASSWORD || 'Wp@ssw0rd54321!' }}" \
          --parameters deploymentPrincipalId="${{ env.DEPLOYMENT_PRINCIPAL_ID }}" \
          --name "github-${{ github.run_number }}"

  deploy-function:
    runs-on: ubuntu-latest
    needs: deploy-infra
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        if [ -f src/requirements.txt ]; then
          pip install -r src/requirements.txt
        fi
        pip install azure-functions
        
    - name: Azure login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
        
    - name: Debug Environment
      run: |
        echo "Function App Name: ${{ env.AZURE_FUNCTIONAPP_NAME }}"
        echo "Admin Portal Name: ${{ env.ADMIN_PORTAL_NAME }}"
        echo "Python Version: ${{ env.PYTHON_VERSION }}"
        echo "Environment: ${{ env.ENVIRONMENT }}"
        echo "Resource Group: ${{ env.RESOURCE_GROUP }}"
      
    # Prepare the function app deployment package (without admin portal)
    - name: Prepare function app deployment package
      run: |
        echo "Preparing function app deployment package"
        mkdir -p function-package
        
        # Copy function code
        cp -r src/* function-package/
        
        # Create required Azure configuration files
        echo '{"version":"2.0","extensionBundle":{"id":"Microsoft.Azure.Functions.ExtensionBundle","version":"[2.*, 3.0.0)"}}' > function-package/host.json
        
        # List the contents of the function package
        echo "Function package contents:"
        ls -la function-package

    - name: Deploy Function App
      uses: Azure/functions-action@v1
      with:
        app-name: ${{ env.AZURE_FUNCTIONAPP_NAME }}
        package: function-package
        scm-do-build-during-deployment: true
        enable-oryx-build: true
      env:
        AZURE_FUNCTIONAPP_PACKAGE_PATH: function-package
        PYTHON_VERSION: ${{ env.PYTHON_VERSION }}

  deploy-admin-portal:
    runs-on: ubuntu-latest
    needs: deploy-infra
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install azure-functions flask gunicorn
        
    - name: Azure login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
        
    # Get admin portal info from Bicep deployment
    - name: Get admin portal information
      run: |
        # Get admin portal web app name from outputs
        ADMIN_PORTAL_NAME=$(az deployment group show \
          --resource-group "${{ env.RESOURCE_GROUP }}" \
          --name "github-${{ github.run_number }}" \
          --query "properties.outputs.adminPortalName.value" \
          --output tsv || echo "${{ env.ADMIN_PORTAL_NAME }}")
        
        echo "Using Admin Portal: $ADMIN_PORTAL_NAME"
        echo "ADMIN_PORTAL_NAME=$ADMIN_PORTAL_NAME" >> $GITHUB_ENV
        
        # Get admin portal hostname
        ADMIN_PORTAL_HOSTNAME=$(az deployment group show \
          --resource-group "${{ env.RESOURCE_GROUP }}" \
          --name "github-${{ github.run_number }}" \
          --query "properties.outputs.adminPortalHostName.value" \
          --output tsv || echo "")
          
        if [ -n "$ADMIN_PORTAL_HOSTNAME" ]; then
          echo "Admin Portal Hostname: $ADMIN_PORTAL_HOSTNAME"
          echo "ADMIN_PORTAL_HOSTNAME=$ADMIN_PORTAL_HOSTNAME" >> $GITHUB_ENV
        fi
          
    # Prepare admin portal deployment package
    - name: Prepare admin portal deployment package
      run: |
        echo "Preparing admin portal deployment package"
        mkdir -p admin-package
        
        # Copy admin portal files
        cp -r templates static admin-package/
        
        # Ensure data directory exists
        mkdir -p admin-package/data
        if [ -d data ]; then
          cp -r data/* admin-package/data/
        fi
        
        # Copy main application files
        cp main.py admin-package/
        cp wsgi.py admin-package/
        
        # Create web.config file
        cat > admin-package/web.config << EOF
        <?xml version="1.0" encoding="utf-8"?>
        <configuration>
          <system.webServer>
            <handlers>
              <add name="PythonHandler" path="*" verb="*" modules="FastCgiModule" 
                   scriptProcessor="D:\Program Files\Python\${{ env.PYTHON_VERSION }}\python.exe|D:\Program Files\Python\${{ env.PYTHON_VERSION }}\Lib\site-packages\wfastcgi.py" 
                   resourceType="Unspecified" requireAccess="Script" />
            </handlers>
            <fastCgi>
              <application fullPath="D:\Program Files\Python\${{ env.PYTHON_VERSION }}\python.exe" 
                           arguments="D:\Program Files\Python\${{ env.PYTHON_VERSION }}\Lib\site-packages\wfastcgi.py">
                <environmentVariables>
                  <environmentVariable name="PYTHONPATH" value="D:\home\site\wwwroot" />
                  <environmentVariable name="WSGI_HANDLER" value="wsgi.application" />
                </environmentVariables>
              </application>
            </fastCgi>
            <rewrite>
              <rules>
                <rule name="LowerCaseUrls" stopProcessing="true">
                  <match url="[A-Z]" ignoreCase="false" />
                  <action type="Redirect" url="{ToLower:{URL}}" />
                </rule>
              </rules>
            </rewrite>
            <httpErrors errorMode="DetailedLocalOnly" existingResponse="Auto">
              <clear />
              <error statusCode="404" path="404.html" responseMode="File" />
              <error statusCode="500" path="500.html" responseMode="File" />
            </httpErrors>
          </system.webServer>
          <appSettings>
            <add key="PYTHONPATH" value="D:\home\site\wwwroot" />
            <add key="WSGI_HANDLER" value="wsgi.application" />
            <add key="WSGI_LOG" value="D:\home\LogFiles\application.log" />
          </appSettings>
        </configuration>
        EOF
        
        # Create 404 and 500 error pages
        cat > admin-package/404.html << EOF
        <!DOCTYPE html>
        <html>
        <head>
            <title>404 - Page Not Found</title>
            <style>
                body { font-family: Arial, sans-serif; margin: 40px; line-height: 1.6; text-align: center; }
                h1 { color: #0066cc; }
                .container { border: 1px solid #ddd; padding: 20px; border-radius: 5px; max-width: 600px; margin: 0 auto; }
            </style>
        </head>
        <body>
            <h1>404 - Page Not Found</h1>
            <div class="container">
                <p>The page you requested could not be found.</p>
                <p><a href="/">Return to Dashboard</a></p>
            </div>
        </body>
        </html>
        EOF
        
        cat > admin-package/500.html << EOF
        <!DOCTYPE html>
        <html>
        <head>
            <title>500 - Server Error</title>
            <style>
                body { font-family: Arial, sans-serif; margin: 40px; line-height: 1.6; text-align: center; }
                h1 { color: #cc0000; }
                .container { border: 1px solid #ddd; padding: 20px; border-radius: 5px; max-width: 600px; margin: 0 auto; }
            </style>
        </head>
        <body>
            <h1>500 - Server Error</h1>
            <div class="container">
                <p>The server encountered an internal error and was unable to complete your request.</p>
                <p>Please try again later or contact the administrator.</p>
                <p><a href="/">Return to Dashboard</a></p>
            </div>
        </body>
        </html>
        EOF
        
        # Create requirements.txt
        cat > admin-package/requirements.txt << EOF
        flask==2.0.3
        gunicorn==20.1.0
        wfastcgi==3.0.0
        python-dotenv==0.21.1
        werkzeug==2.0.3
        azure-functions==1.15.0
        azure-identity==1.12.0
        azure-keyvault-secrets==4.6.0
        azure-storage-blob==12.16.0
        requests==2.29.0
        markdown==3.4.3
        pygments==2.15.1
        langdetect==1.0.9
        trafilatura==1.6.1
        azure-mgmt-storage==21.0.0
        azure-mgmt-resource==22.0.0
        Flask-SQLAlchemy==3.0.3
        sqlalchemy==2.0.12
        psycopg2-binary==2.9.6
        EOF
        
        # Create startup script
        cat > admin-package/startup.sh << EOF
        #!/bin/bash
        echo "Installing required packages..."
        python -m pip install --upgrade pip
        pip install gunicorn flask wfastcgi
        
        echo "Starting admin portal with gunicorn..."
        gunicorn --bind=0.0.0.0:5000 --timeout 600 wsgi:application
        EOF
        chmod +x admin-package/startup.sh
        
        # Ensure proper file permissions
        chmod -R 755 admin-package
        
        # List the contents of the admin package
        echo "Admin portal package contents:"
        ls -la admin-package
        
    # Get storage account info for blob deployment
    - name: Get storage account info
      run: |
        # Get storage account information from deployment
        STORAGE_ACCOUNT_NAME=$(az deployment group show \
          --resource-group "${{ env.RESOURCE_GROUP }}" \
          --name "github-${{ github.run_number }}" \
          --query "properties.outputs.storageAccountName.value" \
          --output tsv)
          
        # Get blob endpoint
        BLOB_ENDPOINT=$(az deployment group show \
          --resource-group "${{ env.RESOURCE_GROUP }}" \
          --name "github-${{ github.run_number }}" \
          --query "properties.outputs.blobEndpoint.value" \
          --output tsv)
          
        echo "Storage Account: $STORAGE_ACCOUNT_NAME"
        echo "STORAGE_ACCOUNT_NAME=$STORAGE_ACCOUNT_NAME" >> $GITHUB_ENV
        
        if [ -n "$BLOB_ENDPOINT" ]; then
          echo "Blob Endpoint: $BLOB_ENDPOINT"
          echo "BLOB_ENDPOINT=$BLOB_ENDPOINT" >> $GITHUB_ENV
        fi
        
    # Deploy admin portal using WEBSITE_RUN_FROM_PACKAGE with blob storage
    - name: Prepare admin portal for deployment
      run: |
        echo "Preparing admin portal deployment package for blob storage"
        
        # Prepare the deployment package
        echo "Creating deployment package ZIP file"
        mkdir -p admin-portal-app
        
        # Copy main files to the deployment package
        cp main.py admin-portal-app/
        cp wsgi.py admin-portal-app/
        cp requirements.txt admin-portal-app/
        
        # Copy templates and static directories
        cp -r templates admin-portal-app/ 2>/dev/null || mkdir -p admin-portal-app/templates
        cp -r static admin-portal-app/ 2>/dev/null || mkdir -p admin-portal-app/static
        
        # Ensure data directory exists
        mkdir -p admin-portal-app/data
        if [ -d data ]; then
          cp -r data/* admin-portal-app/data/ 2>/dev/null || true
        fi
        
        # Copy shared directory if it exists
        if [ -d shared ]; then
          cp -r shared admin-portal-app/shared
        fi
        
        # Create deployment ZIP file
        cd admin-portal-app
        zip -r ../admin-portal-package.zip .
        cd ..
        
        # Get timestamp for unique package name
        TIMESTAMP=$(date +%Y%m%d%H%M%S)
        PACKAGE_NAME="admin-portal-$TIMESTAMP.zip"
        echo "PACKAGE_NAME=$PACKAGE_NAME" >> $GITHUB_ENV
        
        # Upload package to blob storage using the storage account's RBAC permissions
        echo "Uploading package to blob storage"
        az storage blob upload \
          --account-name "${{ env.STORAGE_ACCOUNT_NAME }}" \
          --container-name "deployment-packages" \
          --name "$PACKAGE_NAME" \
          --file "admin-portal-package.zip" \
          --auth-mode login
          
        # Generate SAS URL for the package
        echo "Generating SAS URL with read-only access"
        PACKAGE_URL=$(az storage blob url \
          --account-name "${{ env.STORAGE_ACCOUNT_NAME }}" \
          --container-name "deployment-packages" \
          --name "$PACKAGE_NAME" \
          --output tsv)
          
        # Generate a SAS token that expires in 30 days
        EXPIRY=$(date -u -d "30 days" '+%Y-%m-%dT%H:%MZ')
        SAS_TOKEN=$(az storage container generate-sas \
          --account-name "${{ env.STORAGE_ACCOUNT_NAME }}" \
          --name "deployment-packages" \
          --permissions r \
          --expiry "$EXPIRY" \
          --auth-mode login \
          --as-user \
          --output tsv)
          
        PACKAGE_URL_WITH_SAS="${PACKAGE_URL}?${SAS_TOKEN}"
        echo "PACKAGE_URL=$PACKAGE_URL_WITH_SAS" >> $GITHUB_ENV
        
    # Deploy the admin portal using WEBSITE_RUN_FROM_PACKAGE
    - name: Deploy to Azure Web App
      run: |
        echo "Configuring the web app to use the package from blob storage"
        az webapp config appsettings set \
          --resource-group "${{ env.RESOURCE_GROUP }}" \
          --name "${{ env.ADMIN_PORTAL_NAME }}" \
          --settings \
          WEBSITE_RUN_FROM_PACKAGE="${{ env.PACKAGE_URL }}" \
          SCM_DO_BUILD_DURING_DEPLOYMENT=true \
          ENABLE_ORYX_BUILD=true
          
        # Restart the web app to apply the new settings
        echo "Restarting the web app"
        az webapp restart \
          --resource-group "${{ env.RESOURCE_GROUP }}" \
          --name "${{ env.ADMIN_PORTAL_NAME }}"
        
    # Configure admin portal startup command and settings
    - name: Configure admin portal environment
      run: |
        # Set Linux-specific configuration
        az webapp config set \
          --resource-group "${{ env.RESOURCE_GROUP }}" \
          --name "${{ env.ADMIN_PORTAL_NAME }}" \
          --linux-fx-version "PYTHON|${{ env.PYTHON_VERSION }}" \
          --always-on true \
          --ftps-state Disabled
        
        # Set essential app settings
        az webapp config appsettings set \
          --resource-group "${{ env.RESOURCE_GROUP }}" \
          --name "${{ env.ADMIN_PORTAL_NAME }}" \
          --settings \
          SCM_DO_BUILD_DURING_DEPLOYMENT=true \
          WEBSITES_ENABLE_APP_SERVICE_STORAGE=true \
          FLASK_APP=main.py
        
        echo "Waiting for admin portal to start..."
        sleep 30
        
        # Check if admin portal is accessible
        HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "https://${{ env.ADMIN_PORTAL_NAME }}.azurewebsites.net/")
        echo "Admin portal responded with HTTP code: $HTTP_CODE"
        
        if [ "$HTTP_CODE" = "200" ]; then
          echo "Admin portal deployed and accessible at: https://${{ env.ADMIN_PORTAL_NAME }}.azurewebsites.net/"
        else
          echo "Admin portal deployment may have issues. Check logs in Azure Portal."
          echo "URL: https://${{ env.ADMIN_PORTAL_NAME }}.azurewebsites.net/"
          
          # View logs stream
          echo "---------- SHOWING LOGS STREAM ----------"
          az webapp log tail --resource-group "${{ env.RESOURCE_GROUP }}" --name "${{ env.ADMIN_PORTAL_NAME }}" --timeout 30
        fi